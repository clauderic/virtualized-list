{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///virtualized-list.min.js","webpack:///webpack/bootstrap 1686ec955eaa678331f1","webpack:///./src/VirtualList/index.js","webpack:///./src/InfiniteVirtualList/index.js","webpack:///./src/VirtualList/SizeAndPositionManager.js","webpack:///./~/morphdom/dist/morphdom.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_classCallCheck","instance","Constructor","TypeError","__WEBPACK_IMPORTED_MODULE_0_morphdom__","__WEBPACK_IMPORTED_MODULE_0_morphdom___default","__WEBPACK_IMPORTED_MODULE_1__SizeAndPositionManager__","VirtualizedList","STYLE_INNER","STYLE_CONTENT","container","options","_this","getRowHeight","_ref","index","rowHeight","Array","isArray","state","_initializeSizeAndPositionManager","rowCount","render","bind","handleScroll","componentDidMount","_this2","_options","onMount","initialScrollTop","initialIndex","height","offset","getRowOffset","inner","document","createElement","content","setAttribute","appendChild","setState","scrollTop","addEventListener","count","_sizeAndPositionManager","itemCount","itemSizeGetter","estimatedItemSize","estimatedRowHeight","_this3","arguments","length","undefined","callback","assign","requestAnimationFrame","resize","e","onScroll","getSizeAndPositionForIndex","scrollToIndex","alignment","getUpdatedOffsetForIndex","align","containerSize","targetIndex","setRowCount","onRowsRendered","renderedRows","destroy","removeEventListener","innerHTML","_options2","overscanCount","renderRow","_state","_state$offset","_sizeAndPositionManag2","getVisibleRange","start","stop","fragment","createDocumentFragment","style","getTotalSize","top","childrenOnly","getNodeKey","node","nodeIndex","startIndex","stopIndex","__WEBPACK_IMPORTED_MODULE_0__VirtualList__","__WEBPACK_IMPORTED_MODULE_1__InfiniteVirtualList__","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","isRangeVisible","_ref2","lastRenderedStartIndex","lastRenderedStopIndex","getUnloadedRanges","_ref3","isRowLoaded","minimumBatchSize","unloadedRanges","rangeStartIndex","rangeStopIndex","push","potentialStopIndex","Math","min","max","firstUnloadedRange","InfiniteVirtualList","_VirtualList","apply","loadMoreRows","_options$minimumBatch","_options$rowCount","_options$threshold","threshold","forEach","unloadedRange","promise","then","SizeAndPositionManager","ALIGN_START","ALIGN_CENTER","ALIGN_END","_itemSizeGetter","_itemCount","_estimatedItemSize","_itemSizeAndPositionData","_lastMeasuredIndex","getLastMeasuredIndex","Error","size","lastMeasuredSizeAndPosition","getSizeAndPositionOfLastMeasuredItem","isNaN","_ref2$align","datum","maxOffset","minOffset","idealOffset","totalSize","_findNearestItem","resetItem","_binarySearch","_ref4","low","high","middle","currentOffset","floor","_exponentialSearch","_ref5","interval","lastMeasuredIndex","toElement","str","range","doc","createRange","selectNode","body","createContextualFragment","childNodes","compareNodeNames","fromEl","toEl","fromNodeName","nodeName","toNodeName","actualize","charCodeAt","toUpperCase","createElementNS","namespaceURI","NS_XHTML","moveChildren","curChild","firstChild","nextChild","nextSibling","morphAttrs","fromNode","toNode","attr","attrName","attrNamespaceURI","attrValue","attrs","attributes","localName","getAttributeNS","setAttributeNS","getAttribute","specified","hasAttributeNS","removeAttributeNS","removeAttribute","syncBooleanAttrProp","noop","defaultGetNodeKey","id","morphdomFactory","addKeyedRemoval","key","keyedRemovalList","walkDiscardedChildNodes","skipKeyedNodes","nodeType","ELEMENT_NODE","onNodeDiscarded","removeNode","parentNode","onBeforeNodeDiscarded","removeChild","indexTree","fromNodesLookup","handleNodeAdded","el","onNodeAdded","unmatchedFromEl","replaceChild","morphEl","curFromNodeKey","toElKey","isSameNode","onBeforeElUpdated","onElUpdated","onBeforeElChildrenUpdated","curToNodeKey","fromNextSibling","toNextSibling","matchingFromEl","curToNodeChild","curFromNodeChild","outer","curFromNodeType","isCompatible","insertBefore","TEXT_NODE","COMMENT_NODE","nodeValue","onBeforeNodeAddedResult","onBeforeNodeAdded","ownerDocument","specialElHandler","specialElHandlers","toNodeHtml","morphedNode","morphedNodeType","toNodeType","len","elToRemove","actualHasAttributeNS","testEl","hasAttribute","getAttributeNode","OPTION","INPUT","TEXTAREA","newValue","placeholder","SELECT","selectedIndex","morphdom"],"mappings":"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","file":"virtualized-list.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VirtualizedList\"] = factory();\n\telse\n\t\troot[\"VirtualizedList\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VirtualizedList\"] = factory();\n\telse\n\t\troot[\"VirtualizedList\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_morphdom__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_morphdom___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_morphdom__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SizeAndPositionManager__ = __webpack_require__(3);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return VirtualizedList; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\nvar STYLE_INNER = 'position:relative; overflow:hidden; width:100%; min-height:100%; will-change: transform;';\nvar STYLE_CONTENT = 'position:absolute; top:0; left:0; height:100%; width:100%; overflow:visible;';\n\nvar VirtualizedList = function () {\n  function VirtualizedList(container, options) {\n    var _this = this;\n\n    _classCallCheck(this, VirtualizedList);\n\n    this.getRowHeight = function (_ref) {\n      var index = _ref.index;\n      var rowHeight = _this.options.rowHeight;\n\n\n      if (typeof rowHeight === 'function') {\n        return rowHeight(index);\n      }\n\n      return Array.isArray(rowHeight) ? rowHeight[index] : rowHeight;\n    };\n\n    this.container = container;\n    this.options = options;\n\n    // Initialization\n    this.state = {};\n    this._initializeSizeAndPositionManager(options.rowCount);\n\n    // Binding\n    this.render = this.render.bind(this);\n    this.handleScroll = this.handleScroll.bind(this);\n\n    // Lifecycle Methods\n    this.componentDidMount();\n  }\n\n  VirtualizedList.prototype.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    var _options = this.options,\n        onMount = _options.onMount,\n        initialScrollTop = _options.initialScrollTop,\n        initialIndex = _options.initialIndex,\n        height = _options.height;\n\n    var offset = initialScrollTop || initialIndex != null && this.getRowOffset(initialIndex) || 0;\n    var inner = this.inner = document.createElement('div');\n    var content = this.content = document.createElement('div');\n\n    inner.setAttribute('style', STYLE_INNER);\n    content.setAttribute('style', STYLE_CONTENT);\n    inner.appendChild(content);\n    this.container.appendChild(inner);\n\n    this.setState({\n      offset: offset,\n      height: height\n    }, function () {\n      if (offset) {\n        _this2.container.scrollTop = offset;\n      }\n\n      // Add event listeners\n      _this2.container.addEventListener('scroll', _this2.handleScroll);\n\n      if (typeof onMount === 'function') {\n        onMount();\n      }\n    });\n  };\n\n  VirtualizedList.prototype._initializeSizeAndPositionManager = function _initializeSizeAndPositionManager(count) {\n    this._sizeAndPositionManager = new __WEBPACK_IMPORTED_MODULE_1__SizeAndPositionManager__[\"a\" /* default */]({\n      itemCount: count,\n      itemSizeGetter: this.getRowHeight,\n      estimatedItemSize: this.options.estimatedRowHeight || 100\n    });\n  };\n\n  VirtualizedList.prototype.setState = function setState() {\n    var _this3 = this;\n\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var callback = arguments[1];\n\n    this.state = Object.assign(this.state, state);\n\n    requestAnimationFrame(function () {\n      _this3.render();\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  };\n\n  VirtualizedList.prototype.resize = function resize(height, callback) {\n    this.setState({\n      height: height\n    }, callback);\n  };\n\n  VirtualizedList.prototype.handleScroll = function handleScroll(e) {\n    var onScroll = this.options.onScroll;\n\n    var offset = this.container.scrollTop;\n\n    this.setState({ offset: offset });\n\n    if (typeof onScroll === 'function') {\n      onScroll(offset, e);\n    }\n  };\n\n  VirtualizedList.prototype.getRowOffset = function getRowOffset(index) {\n    var _sizeAndPositionManag = this._sizeAndPositionManager.getSizeAndPositionForIndex(index),\n        offset = _sizeAndPositionManag.offset;\n\n    return offset;\n  };\n\n  VirtualizedList.prototype.scrollToIndex = function scrollToIndex(index, alignment) {\n    var height = this.state.height;\n\n    var offset = this._sizeAndPositionManager.getUpdatedOffsetForIndex({\n      align: alignment,\n      containerSize: height,\n      targetIndex: index\n    });\n\n    this.container.scrollTop = offset;\n  };\n\n  VirtualizedList.prototype.setRowCount = function setRowCount(count) {\n    this._initializeSizeAndPositionManager(count);\n    this.render();\n  };\n\n  VirtualizedList.prototype.onRowsRendered = function onRowsRendered(renderedRows) {\n    var onRowsRendered = this.options.onRowsRendered;\n\n\n    if (typeof onRowsRendered === 'function') {\n      onRowsRendered(renderedRows);\n    }\n  };\n\n  VirtualizedList.prototype.destroy = function destroy() {\n    this.container.removeEventListener('scroll', this.handleScroll);\n    this.container.innerHTML = '';\n  };\n\n  VirtualizedList.prototype.render = function render() {\n    var _options2 = this.options,\n        overscanCount = _options2.overscanCount,\n        renderRow = _options2.renderRow;\n    var _state = this.state,\n        height = _state.height,\n        _state$offset = _state.offset,\n        offset = _state$offset === undefined ? 0 : _state$offset;\n\n    var _sizeAndPositionManag2 = this._sizeAndPositionManager.getVisibleRange({\n      containerSize: height,\n      offset: offset,\n      overscanCount: overscanCount\n    }),\n        start = _sizeAndPositionManag2.start,\n        stop = _sizeAndPositionManag2.stop;\n\n    var fragment = document.createDocumentFragment();\n\n    for (var index = start; index <= stop; index++) {\n      fragment.appendChild(renderRow(index));\n    }\n\n    this.inner.style.height = this._sizeAndPositionManager.getTotalSize() + 'px';\n    this.content.style.top = this.getRowOffset(start) + 'px';\n\n    __WEBPACK_IMPORTED_MODULE_0_morphdom___default()(this.content, fragment, {\n      childrenOnly: true,\n      getNodeKey: function getNodeKey(node) {\n        return node.nodeIndex;\n      }\n    });\n\n    this.onRowsRendered({\n      startIndex: start,\n      stopIndex: stop\n    });\n  };\n\n  return VirtualizedList;\n}();\n\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__VirtualList__ = __webpack_require__(0);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return __WEBPACK_IMPORTED_MODULE_0__VirtualList__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__InfiniteVirtualList__ = __webpack_require__(2);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"InfiniteVirtualList\", function() { return __WEBPACK_IMPORTED_MODULE_1__InfiniteVirtualList__[\"a\"]; });\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__VirtualList__ = __webpack_require__(0);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return InfiniteVirtualList; });\n/* unused harmony export isRangeVisible */\n/* unused harmony export getUnloadedRanges */\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\nvar InfiniteVirtualList = function (_VirtualList) {\n  _inherits(InfiniteVirtualList, _VirtualList);\n\n  function InfiniteVirtualList() {\n    _classCallCheck(this, InfiniteVirtualList);\n\n    return _possibleConstructorReturn(this, _VirtualList.apply(this, arguments));\n  }\n\n  InfiniteVirtualList.prototype.onRowsRendered = function onRowsRendered(_ref) {\n    var _this2 = this;\n\n    var startIndex = _ref.startIndex,\n        stopIndex = _ref.stopIndex;\n    var _options = this.options,\n        isRowLoaded = _options.isRowLoaded,\n        loadMoreRows = _options.loadMoreRows,\n        _options$minimumBatch = _options.minimumBatchSize,\n        minimumBatchSize = _options$minimumBatch === undefined ? 10 : _options$minimumBatch,\n        _options$rowCount = _options.rowCount,\n        rowCount = _options$rowCount === undefined ? 0 : _options$rowCount,\n        _options$threshold = _options.threshold,\n        threshold = _options$threshold === undefined ? 15 : _options$threshold;\n\n\n    var unloadedRanges = getUnloadedRanges({\n      isRowLoaded: isRowLoaded,\n      minimumBatchSize: minimumBatchSize,\n      rowCount: rowCount,\n      startIndex: Math.max(0, startIndex - threshold),\n      stopIndex: Math.min(rowCount - 1, stopIndex + threshold)\n    });\n\n    unloadedRanges.forEach(function (unloadedRange) {\n      var promise = loadMoreRows(unloadedRange);\n\n      if (promise) {\n        promise.then(function () {\n          // Refresh the visible rows if any of them have just been loaded.\n          // Otherwise they will remain in their unloaded visual state.\n          if (isRangeVisible({\n            lastRenderedStartIndex: startIndex,\n            lastRenderedStopIndex: stopIndex,\n            startIndex: unloadedRange.startIndex,\n            stopIndex: unloadedRange.stopIndex\n          })) {\n            // Force update\n            _this2.render();\n          }\n        });\n      }\n    });\n  };\n\n  return InfiniteVirtualList;\n}(__WEBPACK_IMPORTED_MODULE_0__VirtualList__[\"a\" /* default */]);\n\n/**\n * Determines if the specified start/stop range is visible based on the most recently rendered range.\n */\n\n\n\nfunction isRangeVisible(_ref2) {\n  var lastRenderedStartIndex = _ref2.lastRenderedStartIndex,\n      lastRenderedStopIndex = _ref2.lastRenderedStopIndex,\n      startIndex = _ref2.startIndex,\n      stopIndex = _ref2.stopIndex;\n\n  return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);\n}\n\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n */\nfunction getUnloadedRanges(_ref3) {\n  var isRowLoaded = _ref3.isRowLoaded,\n      minimumBatchSize = _ref3.minimumBatchSize,\n      rowCount = _ref3.rowCount,\n      startIndex = _ref3.startIndex,\n      stopIndex = _ref3.stopIndex;\n\n  var unloadedRanges = [];\n  var rangeStartIndex = null;\n  var rangeStopIndex = null;\n\n  for (var index = startIndex; index <= stopIndex; index++) {\n    var loaded = isRowLoaded(index);\n\n    if (!loaded) {\n      rangeStopIndex = index;\n      if (rangeStartIndex === null) {\n        rangeStartIndex = index;\n      }\n    } else if (rangeStopIndex !== null) {\n      unloadedRanges.push({\n        startIndex: rangeStartIndex,\n        stopIndex: rangeStopIndex\n      });\n\n      rangeStartIndex = rangeStopIndex = null;\n    }\n  }\n\n  // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n  if (rangeStopIndex !== null) {\n    var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), rowCount - 1);\n\n    for (var _index = rangeStopIndex + 1; _index <= potentialStopIndex; _index++) {\n      if (!isRowLoaded({ index: _index })) {\n        rangeStopIndex = _index;\n      } else {\n        break;\n      }\n    }\n\n    unloadedRanges.push({\n      startIndex: rangeStartIndex,\n      stopIndex: rangeStopIndex\n    });\n  }\n\n  // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n  if (unloadedRanges.length) {\n    var firstUnloadedRange = unloadedRanges[0];\n\n    while (firstUnloadedRange.stopIndex - firstUnloadedRange.startIndex + 1 < minimumBatchSize && firstUnloadedRange.startIndex > 0) {\n      var _index2 = firstUnloadedRange.startIndex - 1;\n\n      if (!isRowLoaded({ index: _index2 })) {\n        firstUnloadedRange.startIndex = _index2;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return unloadedRanges;\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export ALIGN_START */\n/* unused harmony export ALIGN_CENTER */\n/* unused harmony export ALIGN_END */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return SizeAndPositionManager; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* Forked from react-virtualized 💖 */\nvar ALIGN_START = 'start';\nvar ALIGN_CENTER = 'center';\nvar ALIGN_END = 'end';\n\nvar SizeAndPositionManager = function () {\n  function SizeAndPositionManager(_ref) {\n    var itemCount = _ref.itemCount,\n        itemSizeGetter = _ref.itemSizeGetter,\n        estimatedItemSize = _ref.estimatedItemSize;\n\n    _classCallCheck(this, SizeAndPositionManager);\n\n    this._itemSizeGetter = itemSizeGetter;\n    this._itemCount = itemCount;\n    this._estimatedItemSize = estimatedItemSize;\n\n    // Cache of size and position data for items, mapped by item index.\n    this._itemSizeAndPositionData = {};\n\n    // Measurements for items up to this index can be trusted; items afterward should be estimated.\n    this._lastMeasuredIndex = -1;\n  }\n\n  SizeAndPositionManager.prototype.getLastMeasuredIndex = function getLastMeasuredIndex() {\n    return this._lastMeasuredIndex;\n  };\n\n  /**\n   * This method returns the size and position for the item at the specified index.\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\n   */\n\n\n  SizeAndPositionManager.prototype.getSizeAndPositionForIndex = function getSizeAndPositionForIndex(index) {\n    if (index < 0 || index >= this._itemCount) {\n      throw Error('Requested index ' + index + ' is outside of range 0..' + this._itemCount);\n    }\n\n    if (this._itemCount === 0) {\n      this._lastMeasuredIndex = -1;\n      return {\n        offset: 0,\n        size: 0\n      };\n    }\n\n    if (index > this._lastMeasuredIndex) {\n      var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n      var offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\n\n      for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\n        var size = this._itemSizeGetter({ index: i });\n\n        if (size == null || isNaN(size)) {\n          throw Error('Invalid size returned for index ' + i + ' of value ' + size);\n        }\n\n        this._itemSizeAndPositionData[i] = {\n          offset: offset,\n          size: size\n        };\n\n        offset += size;\n      }\n\n      this._lastMeasuredIndex = index;\n    }\n\n    return this._itemSizeAndPositionData[index];\n  };\n\n  SizeAndPositionManager.prototype.getSizeAndPositionOfLastMeasuredItem = function getSizeAndPositionOfLastMeasuredItem() {\n    return this._lastMeasuredIndex >= 0 ? this._itemSizeAndPositionData[this._lastMeasuredIndex] : { offset: 0, size: 0 };\n  };\n\n  /**\n  * Total size of all items being measured.\n  * This value will be completedly estimated initially.\n  * As items as measured the estimate will be updated.\n  */\n\n\n  SizeAndPositionManager.prototype.getTotalSize = function getTotalSize() {\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n\n    return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this._itemCount - this._lastMeasuredIndex - 1) * this._estimatedItemSize;\n  };\n\n  /**\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\n   *\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @return Offset to use to ensure the specified item is visible\n   */\n\n\n  SizeAndPositionManager.prototype.getUpdatedOffsetForIndex = function getUpdatedOffsetForIndex(_ref2) {\n    var _ref2$align = _ref2.align,\n        align = _ref2$align === undefined ? ALIGN_START : _ref2$align,\n        containerSize = _ref2.containerSize,\n        targetIndex = _ref2.targetIndex;\n\n    if (containerSize <= 0) {\n      return 0;\n    }\n\n    var datum = this.getSizeAndPositionForIndex(targetIndex);\n    var maxOffset = datum.offset;\n    var minOffset = maxOffset - containerSize + datum.size;\n\n    var idealOffset = void 0;\n\n    switch (align) {\n      case ALIGN_END:\n        idealOffset = minOffset;\n        break;\n      case ALIGN_CENTER:\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n      default:\n        idealOffset = maxOffset;\n        break;\n    }\n\n    var totalSize = this.getTotalSize();\n\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  };\n\n  SizeAndPositionManager.prototype.getVisibleRange = function getVisibleRange(_ref3) {\n    var containerSize = _ref3.containerSize,\n        offset = _ref3.offset,\n        overscanCount = _ref3.overscanCount;\n\n    var totalSize = this.getTotalSize();\n\n    if (totalSize === 0) {\n      return {};\n    }\n\n    var maxOffset = offset + containerSize;\n    var start = this._findNearestItem(offset);\n    var stop = start;\n\n    var datum = this.getSizeAndPositionForIndex(start);\n    offset = datum.offset + datum.size;\n\n    while (offset < maxOffset && stop < this._itemCount - 1) {\n      stop++;\n      offset += this.getSizeAndPositionForIndex(stop).size;\n    }\n\n    if (overscanCount) {\n      start = Math.max(0, start - overscanCount);\n      stop = Math.min(stop + overscanCount, this._itemCount - 1);\n    }\n\n    return {\n      start: start,\n      stop: stop\n    };\n  };\n\n  /**\n   * Clear all cached values for items after the specified index.\n   * This method should be called for any item that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n   */\n\n\n  SizeAndPositionManager.prototype.resetItem = function resetItem(index) {\n    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n  };\n\n  SizeAndPositionManager.prototype._binarySearch = function _binarySearch(_ref4) {\n    var low = _ref4.low,\n        high = _ref4.high,\n        offset = _ref4.offset;\n\n    var middle = void 0;\n    var currentOffset = void 0;\n\n    while (low <= high) {\n      middle = low + Math.floor((high - low) / 2);\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n\n      if (currentOffset === offset) {\n        return middle;\n      } else if (currentOffset < offset) {\n        low = middle + 1;\n      } else if (currentOffset > offset) {\n        high = middle - 1;\n      }\n    }\n\n    if (low > 0) {\n      return low - 1;\n    }\n  };\n\n  SizeAndPositionManager.prototype._exponentialSearch = function _exponentialSearch(_ref5) {\n    var index = _ref5.index,\n        offset = _ref5.offset;\n\n    var interval = 1;\n\n    while (index < this._itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {\n      index += interval;\n      interval *= 2;\n    }\n\n    return this._binarySearch({\n      high: Math.min(index, this._itemCount - 1),\n      low: Math.floor(index / 2),\n      offset: offset\n    });\n  };\n\n  /**\n   * Searches for the item (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest item index will be returned.\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\n   */\n\n\n  SizeAndPositionManager.prototype._findNearestItem = function _findNearestItem(offset) {\n    if (isNaN(offset)) {\n      throw Error('Invalid offset ' + offset + ' specified');\n    }\n\n    // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n    offset = Math.max(0, offset);\n\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    var lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\n\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\n      // If we've already measured items within this range just use a binary search as it's faster.\n      return this._binarySearch({\n        high: lastMeasuredIndex,\n        low: 0,\n        offset: offset\n      });\n    } else {\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n      // The overall complexity for this approach is O(log n).\n      return this._exponentialSearch({\n        index: lastMeasuredIndex,\n        offset: offset\n      });\n    }\n  };\n\n  return SizeAndPositionManager;\n}();\n\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\n\nvar testEl = doc ?\n    doc.body || doc.createElement('div') :\n    {};\n\n// Fixes <https://github.com/patrick-steele-idem/morphdom/issues/32>\n// (IE7+ support) <=IE7 does not support el.hasAttribute(name)\nvar actualHasAttributeNS;\n\nif (testEl.hasAttributeNS) {\n    actualHasAttributeNS = function(el, namespaceURI, name) {\n        return el.hasAttributeNS(namespaceURI, name);\n    };\n} else if (testEl.hasAttribute) {\n    actualHasAttributeNS = function(el, namespaceURI, name) {\n        return el.hasAttribute(name);\n    };\n} else {\n    actualHasAttributeNS = function(el, namespaceURI, name) {\n        return el.getAttributeNode(namespaceURI, name) != null;\n    };\n}\n\nvar hasAttributeNS = actualHasAttributeNS;\n\n\nfunction toElement(str) {\n    if (!range && doc.createRange) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment;\n    if (range && range.createContextualFragment) {\n        fragment = range.createContextualFragment(str);\n    } else {\n        fragment = doc.createElement('body');\n        fragment.innerHTML = str;\n    }\n    return fragment.childNodes[0];\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    if (toEl.actualize &&\n        fromNodeName.charCodeAt(0) < 91 && /* from tag name is upper case */\n        toNodeName.charCodeAt(0) > 90 /* target tag name is lower case */) {\n        // If the target element is a virtual DOM node then we may need to normalize the tag name\n        // before comparing. Normal HTML elements that are in the \"http://www.w3.org/1999/xhtml\"\n        // are converted to upper case\n        return fromNodeName === toNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction morphAttrs(fromNode, toNode) {\n    var attrs = toNode.attributes;\n    var i;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    attrs = fromNode.attributes;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            attrNamespaceURI = attr.namespaceURI;\n\n            if (attrNamespaceURI) {\n                attrName = attr.localName || attrName;\n\n                if (!hasAttributeNS(toNode, attrNamespaceURI, attrName)) {\n                    fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n                }\n            } else {\n                if (!hasAttributeNS(toNode, null, attrName)) {\n                    fromNode.removeAttribute(attrName);\n                }\n            }\n        }\n    }\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name, '');\n        }\n    }\n}\n\nvar specialElHandlers = {\n    /**\n     * Needed for IE. Apparently IE doesn't think that \"selected\" is an\n     * attribute when reading over the attributes using selectEl.attributes\n     */\n    OPTION: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!hasAttributeNS(toEl, null, 'value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        if (fromEl.firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            if (newValue === '' && fromEl.firstChild.nodeValue === fromEl.placeholder) {\n                return;\n            }\n\n            fromEl.firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!hasAttributeNS(toEl, null, 'multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            var curChild = toEl.firstChild;\n            while(curChild) {\n                var nodeName = curChild.nodeName;\n                if (nodeName && nodeName.toUpperCase() === 'OPTION') {\n                    if (hasAttributeNS(curChild, null, 'selected')) {\n                        selectedIndex = i;\n                        break;\n                    }\n                    i++;\n                }\n                curChild = curChild.nextSibling;\n            }\n\n            fromEl.selectedIndex = i;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n    return node.id;\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n    return function morphdom(fromNode, toNode, options) {\n        if (!options) {\n            options = {};\n        }\n\n        if (typeof toNode === 'string') {\n            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {\n                var toNodeHtml = toNode;\n                toNode = doc.createElement('html');\n                toNode.innerHTML = toNodeHtml;\n            } else {\n                toNode = toElement(toNode);\n            }\n        }\n\n        var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n        var onNodeAdded = options.onNodeAdded || noop;\n        var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n        var onElUpdated = options.onElUpdated || noop;\n        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n        var onNodeDiscarded = options.onNodeDiscarded || noop;\n        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n        var childrenOnly = options.childrenOnly === true;\n\n        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n        var fromNodesLookup = {};\n        var keyedRemovalList;\n\n        function addKeyedRemoval(key) {\n            if (keyedRemovalList) {\n                keyedRemovalList.push(key);\n            } else {\n                keyedRemovalList = [key];\n            }\n        }\n\n        function walkDiscardedChildNodes(node, skipKeyedNodes) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n\n                    var key = undefined;\n\n                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n                        // If we are skipping keyed nodes then we add the key\n                        // to a list so that it can be handled at the very end.\n                        addKeyedRemoval(key);\n                    } else {\n                        // Only report the node as discarded if it is not keyed. We do this because\n                        // at the end we loop through all keyed elements that were unmatched\n                        // and then discard them in one final pass.\n                        onNodeDiscarded(curChild);\n                        if (curChild.firstChild) {\n                            walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                        }\n                    }\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        /**\n         * Removes a DOM node out of the original DOM\n         *\n         * @param  {Node} node The node to remove\n         * @param  {Node} parentNode The nodes parent\n         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n         * @return {undefined}\n         */\n        function removeNode(node, parentNode, skipKeyedNodes) {\n            if (onBeforeNodeDiscarded(node) === false) {\n                return;\n            }\n\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            onNodeDiscarded(node);\n            walkDiscardedChildNodes(node, skipKeyedNodes);\n        }\n\n        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n        // function indexTree(root) {\n        //     var treeWalker = document.createTreeWalker(\n        //         root,\n        //         NodeFilter.SHOW_ELEMENT);\n        //\n        //     var el;\n        //     while((el = treeWalker.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n        //\n        // function indexTree(node) {\n        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n        //     var el;\n        //     while((el = nodeIterator.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        function indexTree(node) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n                    var key = getNodeKey(curChild);\n                    if (key) {\n                        fromNodesLookup[key] = curChild;\n                    }\n\n                    // Walk recursively\n                    indexTree(curChild);\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        indexTree(fromNode);\n\n        function handleNodeAdded(el) {\n            onNodeAdded(el);\n\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var unmatchedFromEl = fromNodesLookup[key];\n                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n                        morphEl(unmatchedFromEl, curChild);\n                    }\n                }\n\n                handleNodeAdded(curChild);\n                curChild = nextSibling;\n            }\n        }\n\n        function morphEl(fromEl, toEl, childrenOnly) {\n            var toElKey = getNodeKey(toEl);\n            var curFromNodeKey;\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it is will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (toNode.isSameNode && toNode.isSameNode(fromNode)) {\n                return;\n            }\n\n            if (!childrenOnly) {\n                if (onBeforeElUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n\n                morphAttrs(fromEl, toEl);\n                onElUpdated(fromEl);\n\n                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n            }\n\n            if (fromEl.nodeName !== 'TEXTAREA') {\n                var curToNodeChild = toEl.firstChild;\n                var curFromNodeChild = fromEl.firstChild;\n                var curToNodeKey;\n\n                var fromNextSibling;\n                var toNextSibling;\n                var matchingFromEl;\n\n                outer: while (curToNodeChild) {\n                    toNextSibling = curToNodeChild.nextSibling;\n                    curToNodeKey = getNodeKey(curToNodeChild);\n\n                    while (curFromNodeChild) {\n                        fromNextSibling = curFromNodeChild.nextSibling;\n\n                        if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        curFromNodeKey = getNodeKey(curFromNodeChild);\n\n                        var curFromNodeType = curFromNodeChild.nodeType;\n\n                        var isCompatible = undefined;\n\n                        if (curFromNodeType === curToNodeChild.nodeType) {\n                            if (curFromNodeType === ELEMENT_NODE) {\n                                // Both nodes being compared are Element nodes\n\n                                if (curToNodeKey) {\n                                    // The target node has a key so we want to match it up with the correct element\n                                    // in the original DOM tree\n                                    if (curToNodeKey !== curFromNodeKey) {\n                                        // The current element in the original DOM tree does not have a matching key so\n                                        // let's check our lookup to see if there is a matching element in the original\n                                        // DOM tree\n                                        if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                            if (curFromNodeChild.nextSibling === matchingFromEl) {\n                                                // Special case for single element removals. To avoid removing the original\n                                                // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                                // we will instead discard the current node and wait until the next\n                                                // iteration to properly match up the keyed target element with its matching\n                                                // element in the original tree\n                                                isCompatible = false;\n                                            } else {\n                                                // We found a matching keyed element somewhere in the original DOM tree.\n                                                // Let's moving the original DOM node into the current position and morph\n                                                // it.\n\n                                                // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                                // the `removeNode()` function for the node that is being discarded so that\n                                                // all lifecycle hooks are correctly invoked\n                                                fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                                fromNextSibling = curFromNodeChild.nextSibling;\n\n                                                if (curFromNodeKey) {\n                                                    // Since the node is keyed it might be matched up later so we defer\n                                                    // the actual removal to later\n                                                    addKeyedRemoval(curFromNodeKey);\n                                                } else {\n                                                    // NOTE: we skip nested keyed nodes from being removed since there is\n                                                    //       still a chance they will be matched up later\n                                                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                                }\n\n                                                curFromNodeChild = matchingFromEl;\n                                            }\n                                        } else {\n                                            // The nodes are not compatible since the \"to\" node has a key and there\n                                            // is no matching keyed node in the source tree\n                                            isCompatible = false;\n                                        }\n                                    }\n                                } else if (curFromNodeKey) {\n                                    // The original has a key\n                                    isCompatible = false;\n                                }\n\n                                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                                if (isCompatible) {\n                                    // We found compatible DOM elements so transform\n                                    // the current \"from\" node to match the current\n                                    // target DOM node.\n                                    morphEl(curFromNodeChild, curToNodeChild);\n                                }\n\n                            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                                // Both nodes being compared are Text or Comment nodes\n                                isCompatible = true;\n                                // Simply update nodeValue on the original node to\n                                // change the text value\n                                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                            }\n                        }\n\n                        if (isCompatible) {\n                            // Advance both the \"to\" child and the \"from\" child since we found a match\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        // No compatible match so remove the old node from the DOM and continue trying to find a\n                        // match in the original DOM. However, we only do this if the from node is not keyed\n                        // since it is possible that a keyed node might match up with a node somewhere else in the\n                        // target tree and we don't want to discard it just yet since it still might find a\n                        // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                        // that didn't find a home\n                        if (curFromNodeKey) {\n                            // Since the node is keyed it might be matched up later so we defer\n                            // the actual removal to later\n                            addKeyedRemoval(curFromNodeKey);\n                        } else {\n                            // NOTE: we skip nested keyed nodes from being removed since there is\n                            //       still a chance they will be matched up later\n                            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                        }\n\n                        curFromNodeChild = fromNextSibling;\n                    }\n\n                    // If we got this far then we did not find a candidate match for\n                    // our \"to node\" and we exhausted all of the children \"from\"\n                    // nodes. Therefore, we will just append the current \"to\" node\n                    // to the end\n                    if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                        fromEl.appendChild(matchingFromEl);\n                        morphEl(matchingFromEl, curToNodeChild);\n                    } else {\n                        var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n                        if (onBeforeNodeAddedResult !== false) {\n                            if (onBeforeNodeAddedResult) {\n                                curToNodeChild = onBeforeNodeAddedResult;\n                            }\n\n                            if (curToNodeChild.actualize) {\n                                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n                            }\n                            fromEl.appendChild(curToNodeChild);\n                            handleNodeAdded(curToNodeChild);\n                        }\n                    }\n\n                    curToNodeChild = toNextSibling;\n                    curFromNodeChild = fromNextSibling;\n                }\n\n                // We have processed all of the \"to nodes\". If curFromNodeChild is\n                // non-null then we still have some from nodes left over that need\n                // to be removed\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n                    if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                    } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                    }\n                    curFromNodeChild = fromNextSibling;\n                }\n            }\n\n            var specialElHandler = specialElHandlers[fromEl.nodeName];\n            if (specialElHandler) {\n                specialElHandler(fromEl, toEl);\n            }\n        } // END: morphEl(...)\n\n        var morphedNode = fromNode;\n        var morphedNodeType = morphedNode.nodeType;\n        var toNodeType = toNode.nodeType;\n\n        if (!childrenOnly) {\n            // Handle the case where we are given two DOM nodes that are not\n            // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n            if (morphedNodeType === ELEMENT_NODE) {\n                if (toNodeType === ELEMENT_NODE) {\n                    if (!compareNodeNames(fromNode, toNode)) {\n                        onNodeDiscarded(fromNode);\n                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n                    }\n                } else {\n                    // Going from an element node to a text node\n                    morphedNode = toNode;\n                }\n            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n                if (toNodeType === morphedNodeType) {\n                    morphedNode.nodeValue = toNode.nodeValue;\n                    return morphedNode;\n                } else {\n                    // Text node to something else\n                    morphedNode = toNode;\n                }\n            }\n        }\n\n        if (morphedNode === toNode) {\n            // The \"to node\" was not compatible with the \"from node\" so we had to\n            // toss out the \"from node\" and use the \"to node\"\n            onNodeDiscarded(fromNode);\n        } else {\n            morphEl(morphedNode, toNode, childrenOnly);\n\n            // We now need to loop over any keyed nodes that might need to be\n            // removed. We only do the removal if we know that the keyed node\n            // never found a match. When a keyed node is matched up we remove\n            // it out of fromNodesLookup and we use fromNodesLookup to determine\n            // if a keyed node has been matched up or not\n            if (keyedRemovalList) {\n                for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n                    if (elToRemove) {\n                        removeNode(elToRemove, elToRemove.parentNode, false);\n                    }\n                }\n            }\n        }\n\n        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n            if (morphedNode.actualize) {\n                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n            }\n            // If we had to swap out the from node with a new node because the old\n            // node was not compatible with the target node then we need to\n            // replace the old DOM node in the original DOM tree. This is only\n            // possible if the original DOM node was part of a DOM tree which\n            // we know is the case if it has a parent node.\n            fromNode.parentNode.replaceChild(morphedNode, fromNode);\n        }\n\n        return morphedNode;\n    };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nmodule.exports = morphdom;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// virtualized-list.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1686ec955eaa678331f1","import morphdom from 'morphdom';\nimport SizeAndPositionManager from './SizeAndPositionManager';\n\nconst STYLE_INNER = 'position:relative; overflow:hidden; width:100%; min-height:100%; will-change: transform;';\nconst STYLE_CONTENT = 'position:absolute; top:0; left:0; height:100%; width:100%; overflow:visible;';\n\nexport default class VirtualizedList {\n  constructor(container, options) {\n    this.container = container;\n    this.options = options;\n\n    // Initialization\n    this.state = {};\n    this._initializeSizeAndPositionManager(options.rowCount);\n\n    // Binding\n    this.render = this.render.bind(this);\n    this.handleScroll = this.handleScroll.bind(this);\n\n    // Lifecycle Methods\n    this.componentDidMount();\n  }\n\n  componentDidMount() {\n    const {onMount, initialScrollTop, initialIndex, height} = this.options;\n    const offset = (\n      initialScrollTop ||\n      initialIndex != null && this.getRowOffset(initialIndex) ||\n      0\n    );\n    const inner = this.inner = document.createElement('div');\n    const content = this.content = document.createElement('div');\n\n    inner.setAttribute('style', STYLE_INNER);\n    content.setAttribute('style', STYLE_CONTENT);\n    inner.appendChild(content);\n    this.container.appendChild(inner);\n\n    this.setState({\n      offset,\n      height,\n    }, () => {\n      if (offset) {\n        this.container.scrollTop = offset;\n      }\n\n      // Add event listeners\n      this.container.addEventListener('scroll', this.handleScroll);\n\n      if (typeof onMount === 'function') {\n        onMount();\n      }\n    });\n  }\n\n  _initializeSizeAndPositionManager(count) {\n    this._sizeAndPositionManager = new SizeAndPositionManager({\n      itemCount: count,\n      itemSizeGetter: this.getRowHeight,\n      estimatedItemSize: this.options.estimatedRowHeight || 100\n    });\n  }\n\n  setState(state = {}, callback) {\n    this.state = Object.assign(this.state, state);\n\n    requestAnimationFrame(() => {\n      this.render();\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n\n  resize(height, callback) {\n    this.setState({\n      height,\n    }, callback);\n  }\n\n  handleScroll(e) {\n    const {onScroll} = this.options;\n    const offset = this.container.scrollTop;\n\n    this.setState({offset});\n\n    if (typeof onScroll === 'function') {\n      onScroll(offset, e);\n    }\n  }\n\n  getRowHeight = ({index}) => {\n    const {rowHeight} = this.options;\n\n    if (typeof rowHeight === 'function') {\n      return rowHeight(index);\n    }\n\n    return (Array.isArray(rowHeight)) ? rowHeight[index] : rowHeight;\n  }\n\n  getRowOffset(index) {\n    const {offset} = this._sizeAndPositionManager.getSizeAndPositionForIndex(index);\n\n    return offset;\n  }\n\n  scrollToIndex(index, alignment) {\n    const {height} = this.state;\n    const offset = this._sizeAndPositionManager.getUpdatedOffsetForIndex({\n      align: alignment,\n      containerSize: height,\n      targetIndex: index,\n    });\n\n    this.container.scrollTop = offset;\n  }\n\n  setRowCount(count) {\n    this._initializeSizeAndPositionManager(count);\n    this.render();\n  }\n\n  onRowsRendered(renderedRows) {\n    const {onRowsRendered} = this.options;\n\n    if (typeof onRowsRendered === 'function') {\n      onRowsRendered(renderedRows);\n    }\n  }\n\n  destroy() {\n    this.container.removeEventListener('scroll', this.handleScroll);\n    this.container.innerHTML = '';\n  }\n\n  render() {\n    const {overscanCount, renderRow} = this.options;\n    const {height, offset = 0} = this.state;\n    const {start, stop} = this._sizeAndPositionManager.getVisibleRange({\n      containerSize: height,\n      offset,\n      overscanCount,\n    });\n    const fragment = document.createDocumentFragment();\n\n    for (let index = start; index <= stop; index++) {\n      fragment.appendChild(renderRow(index));\n    }\n\n    this.inner.style.height = `${this._sizeAndPositionManager.getTotalSize()}px`;\n    this.content.style.top = `${this.getRowOffset(start)}px`;\n\n    morphdom(this.content, fragment, {\n      childrenOnly: true,\n      getNodeKey: node => node.nodeIndex,\n    });\n\n    this.onRowsRendered({\n      startIndex: start,\n      stopIndex: stop,\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/VirtualList/index.js","import VirtualList from '../VirtualList';\n\nexport default class InfiniteVirtualList extends VirtualList {\n  onRowsRendered({startIndex, stopIndex}) {\n    const {\n      isRowLoaded,\n      loadMoreRows,\n      minimumBatchSize = 10,\n      rowCount = 0,\n      threshold = 15,\n    } = this.options;\n\n    const unloadedRanges = getUnloadedRanges({\n      isRowLoaded,\n      minimumBatchSize,\n      rowCount,\n      startIndex: Math.max(0, startIndex - threshold),\n      stopIndex: Math.min(rowCount - 1, stopIndex + threshold),\n    });\n\n    unloadedRanges.forEach(unloadedRange => {\n      let promise = loadMoreRows(unloadedRange);\n\n      if (promise) {\n        promise.then(() => {\n          // Refresh the visible rows if any of them have just been loaded.\n          // Otherwise they will remain in their unloaded visual state.\n          if (\n            isRangeVisible({\n              lastRenderedStartIndex: startIndex,\n              lastRenderedStopIndex: stopIndex,\n              startIndex: unloadedRange.startIndex,\n              stopIndex: unloadedRange.stopIndex,\n            })\n          ) {\n            // Force update\n            this.render();\n          }\n        });\n      }\n    });\n  }\n}\n\n/**\n * Determines if the specified start/stop range is visible based on the most recently rendered range.\n */\nexport function isRangeVisible ({\n  lastRenderedStartIndex,\n  lastRenderedStopIndex,\n  startIndex,\n  stopIndex\n}) {\n  return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);\n}\n\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n */\nexport function getUnloadedRanges ({\n  isRowLoaded,\n  minimumBatchSize,\n  rowCount,\n  startIndex,\n  stopIndex\n}) {\n  const unloadedRanges = [];\n  let rangeStartIndex = null;\n  let rangeStopIndex = null;\n\n  for (let index = startIndex; index <= stopIndex; index++) {\n    let loaded = isRowLoaded(index);\n\n    if (!loaded) {\n      rangeStopIndex = index;\n      if (rangeStartIndex === null) {\n        rangeStartIndex = index;\n      }\n    } else if (rangeStopIndex !== null) {\n      unloadedRanges.push({\n        startIndex: rangeStartIndex,\n        stopIndex: rangeStopIndex,\n      });\n\n      rangeStartIndex = rangeStopIndex = null;\n    }\n  }\n\n  // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n  if (rangeStopIndex !== null) {\n    const potentialStopIndex = Math.min(\n      Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1),\n      rowCount - 1,\n    );\n\n    for (let index = rangeStopIndex + 1; index <= potentialStopIndex; index++) {\n      if (!isRowLoaded({index})) {\n        rangeStopIndex = index;\n      } else {\n        break;\n      }\n    }\n\n    unloadedRanges.push({\n      startIndex: rangeStartIndex,\n      stopIndex: rangeStopIndex,\n    });\n  }\n\n  // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n  if (unloadedRanges.length) {\n    const firstUnloadedRange = unloadedRanges[0];\n\n    while (\n      firstUnloadedRange.stopIndex - firstUnloadedRange.startIndex + 1 < minimumBatchSize &&\n      firstUnloadedRange.startIndex > 0\n    ) {\n      let index = firstUnloadedRange.startIndex - 1;\n\n      if (!isRowLoaded({index})) {\n        firstUnloadedRange.startIndex = index;\n      } else {\n        break;\n      }\n    }\n  }\n\n\n  return unloadedRanges;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/InfiniteVirtualList/index.js","/* Forked from react-virtualized 💖 */\nexport const ALIGN_START = 'start';\nexport const ALIGN_CENTER = 'center';\nexport const ALIGN_END = 'end';\n\nexport default class SizeAndPositionManager {\n  constructor({\n    itemCount,\n    itemSizeGetter,\n    estimatedItemSize,\n  }) {\n    this._itemSizeGetter = itemSizeGetter;\n    this._itemCount = itemCount;\n    this._estimatedItemSize = estimatedItemSize;\n\n    // Cache of size and position data for items, mapped by item index.\n    this._itemSizeAndPositionData = {};\n\n    // Measurements for items up to this index can be trusted; items afterward should be estimated.\n    this._lastMeasuredIndex = -1;\n  }\n\n  getLastMeasuredIndex() {\n    return this._lastMeasuredIndex;\n  }\n\n  /**\n   * This method returns the size and position for the item at the specified index.\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\n   */\n  getSizeAndPositionForIndex(index) {\n    if (index < 0 || index >= this._itemCount) {\n      throw Error(`Requested index ${index} is outside of range 0..${this._itemCount}`);\n    }\n\n    if (this._itemCount === 0) {\n      this._lastMeasuredIndex = -1;\n      return {\n        offset: 0,\n        size: 0\n      };\n    }\n\n    if (index > this._lastMeasuredIndex) {\n      let lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n      let offset = lastMeasuredSizeAndPosition.offset +\n        lastMeasuredSizeAndPosition.size;\n\n      for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\n        let size = this._itemSizeGetter({index: i});\n\n        if (size == null || isNaN(size)) {\n          throw Error(`Invalid size returned for index ${i} of value ${size}`);\n        }\n\n        this._itemSizeAndPositionData[i] = {\n          offset,\n          size,\n        };\n\n        offset += size;\n      }\n\n      this._lastMeasuredIndex = index;\n    }\n\n    return this._itemSizeAndPositionData[index];\n  }\n\n  getSizeAndPositionOfLastMeasuredItem() {\n    return this._lastMeasuredIndex >= 0\n      ? this._itemSizeAndPositionData[this._lastMeasuredIndex]\n      : {offset: 0, size: 0};\n  }\n\n  /**\n  * Total size of all items being measured.\n  * This value will be completedly estimated initially.\n  * As items as measured the estimate will be updated.\n  */\n  getTotalSize() {\n    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n\n    return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this._itemCount - this._lastMeasuredIndex - 1) * this._estimatedItemSize;\n  }\n\n  /**\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\n   *\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @return Offset to use to ensure the specified item is visible\n   */\n  getUpdatedOffsetForIndex({\n    align = ALIGN_START,\n    containerSize,\n    targetIndex,\n  }) {\n    if (containerSize <= 0) {\n      return 0;\n    }\n\n    const datum = this.getSizeAndPositionForIndex(targetIndex);\n    const maxOffset = datum.offset;\n    const minOffset = maxOffset - containerSize + datum.size;\n\n    let idealOffset;\n\n    switch (align) {\n      case ALIGN_END:\n        idealOffset = minOffset;\n        break;\n      case ALIGN_CENTER:\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n      default:\n        idealOffset = maxOffset;\n        break;\n    }\n\n    const totalSize = this.getTotalSize();\n\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  }\n\n  getVisibleRange({containerSize, offset, overscanCount}) {\n    const totalSize = this.getTotalSize();\n\n    if (totalSize === 0) { return {}; }\n\n    const maxOffset = offset + containerSize;\n    let start = this._findNearestItem(offset);\n    let stop = start;\n\n    const datum = this.getSizeAndPositionForIndex(start);\n    offset = datum.offset + datum.size;\n\n    while (offset < maxOffset && stop < this._itemCount - 1) {\n      stop++;\n      offset += this.getSizeAndPositionForIndex(stop).size;\n    }\n\n    if (overscanCount) {\n      start = Math.max(0, start - overscanCount);\n      stop = Math.min(stop + overscanCount, this._itemCount - 1);\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n\n  /**\n   * Clear all cached values for items after the specified index.\n   * This method should be called for any item that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n   */\n  resetItem(index) {\n    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n  }\n\n  _binarySearch({low, high, offset}) {\n    let middle;\n    let currentOffset;\n\n    while (low <= high) {\n      middle = low + Math.floor((high - low) / 2);\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n\n      if (currentOffset === offset) {\n        return middle;\n      } else if (currentOffset < offset) {\n        low = middle + 1;\n      } else if (currentOffset > offset) {\n        high = middle - 1;\n      }\n    }\n\n    if (low > 0) {\n      return low - 1;\n    }\n  }\n\n  _exponentialSearch({index, offset}) {\n    let interval = 1;\n\n    while (\n      index < this._itemCount &&\n      this.getSizeAndPositionForIndex(index).offset < offset\n    ) {\n      index += interval;\n      interval *= 2;\n    }\n\n    return this._binarySearch({\n      high: Math.min(index, this._itemCount - 1),\n      low: Math.floor(index / 2),\n      offset,\n    });\n  }\n\n  /**\n   * Searches for the item (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest item index will be returned.\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\n   */\n  _findNearestItem(offset) {\n    if (isNaN(offset)) {\n      throw Error(`Invalid offset ${offset} specified`);\n    }\n\n    // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n    offset = Math.max(0, offset);\n\n    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    const lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\n\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\n      // If we've already measured items within this range just use a binary search as it's faster.\n      return this._binarySearch({\n        high: lastMeasuredIndex,\n        low: 0,\n        offset,\n      });\n    } else {\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n      // The overall complexity for this approach is O(log n).\n      return this._exponentialSearch({\n        index: lastMeasuredIndex,\n        offset,\n      });\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/VirtualList/SizeAndPositionManager.js","'use strict';\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\n\nvar testEl = doc ?\n    doc.body || doc.createElement('div') :\n    {};\n\n// Fixes <https://github.com/patrick-steele-idem/morphdom/issues/32>\n// (IE7+ support) <=IE7 does not support el.hasAttribute(name)\nvar actualHasAttributeNS;\n\nif (testEl.hasAttributeNS) {\n    actualHasAttributeNS = function(el, namespaceURI, name) {\n        return el.hasAttributeNS(namespaceURI, name);\n    };\n} else if (testEl.hasAttribute) {\n    actualHasAttributeNS = function(el, namespaceURI, name) {\n        return el.hasAttribute(name);\n    };\n} else {\n    actualHasAttributeNS = function(el, namespaceURI, name) {\n        return el.getAttributeNode(namespaceURI, name) != null;\n    };\n}\n\nvar hasAttributeNS = actualHasAttributeNS;\n\n\nfunction toElement(str) {\n    if (!range && doc.createRange) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment;\n    if (range && range.createContextualFragment) {\n        fragment = range.createContextualFragment(str);\n    } else {\n        fragment = doc.createElement('body');\n        fragment.innerHTML = str;\n    }\n    return fragment.childNodes[0];\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    if (toEl.actualize &&\n        fromNodeName.charCodeAt(0) < 91 && /* from tag name is upper case */\n        toNodeName.charCodeAt(0) > 90 /* target tag name is lower case */) {\n        // If the target element is a virtual DOM node then we may need to normalize the tag name\n        // before comparing. Normal HTML elements that are in the \"http://www.w3.org/1999/xhtml\"\n        // are converted to upper case\n        return fromNodeName === toNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction morphAttrs(fromNode, toNode) {\n    var attrs = toNode.attributes;\n    var i;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    attrs = fromNode.attributes;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            attrNamespaceURI = attr.namespaceURI;\n\n            if (attrNamespaceURI) {\n                attrName = attr.localName || attrName;\n\n                if (!hasAttributeNS(toNode, attrNamespaceURI, attrName)) {\n                    fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n                }\n            } else {\n                if (!hasAttributeNS(toNode, null, attrName)) {\n                    fromNode.removeAttribute(attrName);\n                }\n            }\n        }\n    }\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name, '');\n        }\n    }\n}\n\nvar specialElHandlers = {\n    /**\n     * Needed for IE. Apparently IE doesn't think that \"selected\" is an\n     * attribute when reading over the attributes using selectEl.attributes\n     */\n    OPTION: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!hasAttributeNS(toEl, null, 'value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        if (fromEl.firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            if (newValue === '' && fromEl.firstChild.nodeValue === fromEl.placeholder) {\n                return;\n            }\n\n            fromEl.firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!hasAttributeNS(toEl, null, 'multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            var curChild = toEl.firstChild;\n            while(curChild) {\n                var nodeName = curChild.nodeName;\n                if (nodeName && nodeName.toUpperCase() === 'OPTION') {\n                    if (hasAttributeNS(curChild, null, 'selected')) {\n                        selectedIndex = i;\n                        break;\n                    }\n                    i++;\n                }\n                curChild = curChild.nextSibling;\n            }\n\n            fromEl.selectedIndex = i;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n    return node.id;\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n    return function morphdom(fromNode, toNode, options) {\n        if (!options) {\n            options = {};\n        }\n\n        if (typeof toNode === 'string') {\n            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {\n                var toNodeHtml = toNode;\n                toNode = doc.createElement('html');\n                toNode.innerHTML = toNodeHtml;\n            } else {\n                toNode = toElement(toNode);\n            }\n        }\n\n        var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n        var onNodeAdded = options.onNodeAdded || noop;\n        var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n        var onElUpdated = options.onElUpdated || noop;\n        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n        var onNodeDiscarded = options.onNodeDiscarded || noop;\n        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n        var childrenOnly = options.childrenOnly === true;\n\n        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n        var fromNodesLookup = {};\n        var keyedRemovalList;\n\n        function addKeyedRemoval(key) {\n            if (keyedRemovalList) {\n                keyedRemovalList.push(key);\n            } else {\n                keyedRemovalList = [key];\n            }\n        }\n\n        function walkDiscardedChildNodes(node, skipKeyedNodes) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n\n                    var key = undefined;\n\n                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n                        // If we are skipping keyed nodes then we add the key\n                        // to a list so that it can be handled at the very end.\n                        addKeyedRemoval(key);\n                    } else {\n                        // Only report the node as discarded if it is not keyed. We do this because\n                        // at the end we loop through all keyed elements that were unmatched\n                        // and then discard them in one final pass.\n                        onNodeDiscarded(curChild);\n                        if (curChild.firstChild) {\n                            walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                        }\n                    }\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        /**\n         * Removes a DOM node out of the original DOM\n         *\n         * @param  {Node} node The node to remove\n         * @param  {Node} parentNode The nodes parent\n         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n         * @return {undefined}\n         */\n        function removeNode(node, parentNode, skipKeyedNodes) {\n            if (onBeforeNodeDiscarded(node) === false) {\n                return;\n            }\n\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            onNodeDiscarded(node);\n            walkDiscardedChildNodes(node, skipKeyedNodes);\n        }\n\n        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n        // function indexTree(root) {\n        //     var treeWalker = document.createTreeWalker(\n        //         root,\n        //         NodeFilter.SHOW_ELEMENT);\n        //\n        //     var el;\n        //     while((el = treeWalker.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n        //\n        // function indexTree(node) {\n        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n        //     var el;\n        //     while((el = nodeIterator.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        function indexTree(node) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n                    var key = getNodeKey(curChild);\n                    if (key) {\n                        fromNodesLookup[key] = curChild;\n                    }\n\n                    // Walk recursively\n                    indexTree(curChild);\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        indexTree(fromNode);\n\n        function handleNodeAdded(el) {\n            onNodeAdded(el);\n\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var unmatchedFromEl = fromNodesLookup[key];\n                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n                        morphEl(unmatchedFromEl, curChild);\n                    }\n                }\n\n                handleNodeAdded(curChild);\n                curChild = nextSibling;\n            }\n        }\n\n        function morphEl(fromEl, toEl, childrenOnly) {\n            var toElKey = getNodeKey(toEl);\n            var curFromNodeKey;\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it is will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (toNode.isSameNode && toNode.isSameNode(fromNode)) {\n                return;\n            }\n\n            if (!childrenOnly) {\n                if (onBeforeElUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n\n                morphAttrs(fromEl, toEl);\n                onElUpdated(fromEl);\n\n                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n            }\n\n            if (fromEl.nodeName !== 'TEXTAREA') {\n                var curToNodeChild = toEl.firstChild;\n                var curFromNodeChild = fromEl.firstChild;\n                var curToNodeKey;\n\n                var fromNextSibling;\n                var toNextSibling;\n                var matchingFromEl;\n\n                outer: while (curToNodeChild) {\n                    toNextSibling = curToNodeChild.nextSibling;\n                    curToNodeKey = getNodeKey(curToNodeChild);\n\n                    while (curFromNodeChild) {\n                        fromNextSibling = curFromNodeChild.nextSibling;\n\n                        if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        curFromNodeKey = getNodeKey(curFromNodeChild);\n\n                        var curFromNodeType = curFromNodeChild.nodeType;\n\n                        var isCompatible = undefined;\n\n                        if (curFromNodeType === curToNodeChild.nodeType) {\n                            if (curFromNodeType === ELEMENT_NODE) {\n                                // Both nodes being compared are Element nodes\n\n                                if (curToNodeKey) {\n                                    // The target node has a key so we want to match it up with the correct element\n                                    // in the original DOM tree\n                                    if (curToNodeKey !== curFromNodeKey) {\n                                        // The current element in the original DOM tree does not have a matching key so\n                                        // let's check our lookup to see if there is a matching element in the original\n                                        // DOM tree\n                                        if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                            if (curFromNodeChild.nextSibling === matchingFromEl) {\n                                                // Special case for single element removals. To avoid removing the original\n                                                // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                                // we will instead discard the current node and wait until the next\n                                                // iteration to properly match up the keyed target element with its matching\n                                                // element in the original tree\n                                                isCompatible = false;\n                                            } else {\n                                                // We found a matching keyed element somewhere in the original DOM tree.\n                                                // Let's moving the original DOM node into the current position and morph\n                                                // it.\n\n                                                // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                                // the `removeNode()` function for the node that is being discarded so that\n                                                // all lifecycle hooks are correctly invoked\n                                                fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                                fromNextSibling = curFromNodeChild.nextSibling;\n\n                                                if (curFromNodeKey) {\n                                                    // Since the node is keyed it might be matched up later so we defer\n                                                    // the actual removal to later\n                                                    addKeyedRemoval(curFromNodeKey);\n                                                } else {\n                                                    // NOTE: we skip nested keyed nodes from being removed since there is\n                                                    //       still a chance they will be matched up later\n                                                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                                }\n\n                                                curFromNodeChild = matchingFromEl;\n                                            }\n                                        } else {\n                                            // The nodes are not compatible since the \"to\" node has a key and there\n                                            // is no matching keyed node in the source tree\n                                            isCompatible = false;\n                                        }\n                                    }\n                                } else if (curFromNodeKey) {\n                                    // The original has a key\n                                    isCompatible = false;\n                                }\n\n                                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                                if (isCompatible) {\n                                    // We found compatible DOM elements so transform\n                                    // the current \"from\" node to match the current\n                                    // target DOM node.\n                                    morphEl(curFromNodeChild, curToNodeChild);\n                                }\n\n                            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                                // Both nodes being compared are Text or Comment nodes\n                                isCompatible = true;\n                                // Simply update nodeValue on the original node to\n                                // change the text value\n                                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                            }\n                        }\n\n                        if (isCompatible) {\n                            // Advance both the \"to\" child and the \"from\" child since we found a match\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        // No compatible match so remove the old node from the DOM and continue trying to find a\n                        // match in the original DOM. However, we only do this if the from node is not keyed\n                        // since it is possible that a keyed node might match up with a node somewhere else in the\n                        // target tree and we don't want to discard it just yet since it still might find a\n                        // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                        // that didn't find a home\n                        if (curFromNodeKey) {\n                            // Since the node is keyed it might be matched up later so we defer\n                            // the actual removal to later\n                            addKeyedRemoval(curFromNodeKey);\n                        } else {\n                            // NOTE: we skip nested keyed nodes from being removed since there is\n                            //       still a chance they will be matched up later\n                            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                        }\n\n                        curFromNodeChild = fromNextSibling;\n                    }\n\n                    // If we got this far then we did not find a candidate match for\n                    // our \"to node\" and we exhausted all of the children \"from\"\n                    // nodes. Therefore, we will just append the current \"to\" node\n                    // to the end\n                    if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                        fromEl.appendChild(matchingFromEl);\n                        morphEl(matchingFromEl, curToNodeChild);\n                    } else {\n                        var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n                        if (onBeforeNodeAddedResult !== false) {\n                            if (onBeforeNodeAddedResult) {\n                                curToNodeChild = onBeforeNodeAddedResult;\n                            }\n\n                            if (curToNodeChild.actualize) {\n                                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n                            }\n                            fromEl.appendChild(curToNodeChild);\n                            handleNodeAdded(curToNodeChild);\n                        }\n                    }\n\n                    curToNodeChild = toNextSibling;\n                    curFromNodeChild = fromNextSibling;\n                }\n\n                // We have processed all of the \"to nodes\". If curFromNodeChild is\n                // non-null then we still have some from nodes left over that need\n                // to be removed\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n                    if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                    } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                    }\n                    curFromNodeChild = fromNextSibling;\n                }\n            }\n\n            var specialElHandler = specialElHandlers[fromEl.nodeName];\n            if (specialElHandler) {\n                specialElHandler(fromEl, toEl);\n            }\n        } // END: morphEl(...)\n\n        var morphedNode = fromNode;\n        var morphedNodeType = morphedNode.nodeType;\n        var toNodeType = toNode.nodeType;\n\n        if (!childrenOnly) {\n            // Handle the case where we are given two DOM nodes that are not\n            // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n            if (morphedNodeType === ELEMENT_NODE) {\n                if (toNodeType === ELEMENT_NODE) {\n                    if (!compareNodeNames(fromNode, toNode)) {\n                        onNodeDiscarded(fromNode);\n                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n                    }\n                } else {\n                    // Going from an element node to a text node\n                    morphedNode = toNode;\n                }\n            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n                if (toNodeType === morphedNodeType) {\n                    morphedNode.nodeValue = toNode.nodeValue;\n                    return morphedNode;\n                } else {\n                    // Text node to something else\n                    morphedNode = toNode;\n                }\n            }\n        }\n\n        if (morphedNode === toNode) {\n            // The \"to node\" was not compatible with the \"from node\" so we had to\n            // toss out the \"from node\" and use the \"to node\"\n            onNodeDiscarded(fromNode);\n        } else {\n            morphEl(morphedNode, toNode, childrenOnly);\n\n            // We now need to loop over any keyed nodes that might need to be\n            // removed. We only do the removal if we know that the keyed node\n            // never found a match. When a keyed node is matched up we remove\n            // it out of fromNodesLookup and we use fromNodesLookup to determine\n            // if a keyed node has been matched up or not\n            if (keyedRemovalList) {\n                for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n                    if (elToRemove) {\n                        removeNode(elToRemove, elToRemove.parentNode, false);\n                    }\n                }\n            }\n        }\n\n        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n            if (morphedNode.actualize) {\n                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n            }\n            // If we had to swap out the from node with a new node because the old\n            // node was not compatible with the target node then we need to\n            // replace the old DOM node in the original DOM tree. This is only\n            // possible if the original DOM node was part of a DOM tree which\n            // we know is the case if it has a parent node.\n            fromNode.parentNode.replaceChild(morphedNode, fromNode);\n        }\n\n        return morphedNode;\n    };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nmodule.exports = morphdom;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/morphdom/dist/morphdom.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}